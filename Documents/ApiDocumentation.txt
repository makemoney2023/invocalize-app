
## Overview


This document provides comprehensive details about the API endpoints available in the **Voice AI Call Data Management System**. The APIs are built using Next.js API routes with TypeScript and integrate with Supabase and OpenAI services. All endpoints are type-safe and validated using Zod schemas.


- **Development**: `http://localhost:3000/api`

- **Production**: `https://your-production-domain.com/api`

Currently, the APIs do not require authentication. However, it's recommended to implement authentication (e.g., using Supabase Auth) to secure the endpoints in the future.


### 1. Analyze Transcript

- **Method**: `POST`
URL: /api/analyze-transcript
Method: POST
Description: Analyzes a call transcript using OpenAI's GPT-3.5-turbo model and stores the analysis results in the database.
Request
Headers:
Content-Type: application/json
Body Parameters:
  {
    "leadId": "string",
    "transcript": "string"
  }

leadId (string, required): The unique identifier of the lead associated with the transcript.
transcript (string, required): The full transcript of the call to be analyzed.
Response
Success (200 OK):
Body:
  {
    "data": {
      "id": "string",
      "lead_id": "string",
      "sentiment_score": number,
      "key_points": ["string"],
      "customer_satisfaction": "string",
      "appointment_details": "string",
      "created_at": "string (ISO 8601 date)"
    },
    "message": "Analysis successful."
  }

data: Object containing the analysis result stored in the database.
message: Success message.
Error (4xx or 5xx):
  {
    "error": "string"
  }
  error: Error message describing what went wrong.
Example
Request:
POST /api/analyze-transcript
Content-Type: application/json

{
  "leadId": "123e4567-e89b-12d3-a456-426614174000",
  "transcript": "Hello, I am interested in your services..."
}

Response:
{
  "data": {
    "id": "abc123",
    "lead_id": "123e4567-e89b-12d3-a456-426614174000",
    "sentiment_score": 0.85,
    "key_points": [
      "Interest in services",
      "Requested pricing information"
    ],
    "customer_satisfaction": "Satisfied",
    "appointment_details": "Appointment scheduled for next week",
    "created_at": "2023-10-01T12:34:56Z"
  },
  "message": "Analysis successful."
}

2. Fetch Leads
URL: /api/leads
Method: GET
Description: Retrieves a list of leads along with their associated call analyses.
(Note: Based on provided code snippets, this endpoint is inferred. Adapt as necessary.)
Request
Headers:
Content-Type: application/json
Query Parameters: None
Response
Success (200 OK):
Body:

  {
    "data": [
      {
        "id": "string",
        "name": "string",
        "email": "string",
        "phone_number": "string",
        "use_case": "string",
        "created_at": "string (ISO 8601 date)",
        "call_length": number,
        "price": number,
        "summary": "string",
        "concatenated_transcript": "string",
        "call_analyses": [
          {
            "sentiment_score": number,
            "key_points": ["string"],
            "customer_satisfaction": "string",
            "appointment_details": "string"
          }
        ]
      }
    ]
  }

data: Array of lead objects, each containing a list of call analyses.
Error (4xx or 5xx):
Body:

  {
    "error": "string"
  }

  error: Error message.
---
3. Fetch Appointments
URL: /api/appointments
Method: GET
Description: Retrieves a list of scheduled appointments.
(Note: This endpoint is inferred based on code snippets.)
Request
Headers:
Content-Type: application/json
Query Parameters: None
Response
Success (200 OK):
Body:

  {
    "data": [
      {
        "id": "string",
        "lead_id": "string",
        "date": "string (YYYY-MM-DD)",
        "time": "string (HH:MM:SS)",
        "note": "string",
        "name": "string",
        "email": "string",
        "phone_number": "string",
        "use_case": "string"
      }
    ]
  }

  Error (4xx or 5xx):
Body:

  {
    "error": "string"
  }


Request and Response Schemas
Analyze Transcript Request Schema
interface AnalyzeTranscriptRequest {
  leadId: string;
  transcript: string;
}

Analyze Transcript Response Schema
interface AnalyzeTranscriptResponse {
  data: {
    id: string;
    lead_id: string;
    sentiment_score: number;
    key_points: string[];
    customer_satisfaction: string;
    appointment_details: string;
    created_at: string; // ISO 8601 date string
  };
  message: string;
}

Error Handling
400 Bad Request: The request could not be understood by the server due to malformed syntax. The client SHOULD NOT repeat the request without modifications.
404 Not Found: The requested resource could not be found.
500 Internal Server Error: The server encountered an unexpected condition which prevented it from fulfilling the request.
Error responses include an error field with a descriptive message.
---
Validation
All incoming requests are validated using Zod schemas to ensure type safety and data integrity. Invalid requests will receive a 400 Bad Request response with details about the validation errors.
Example of request validation using Zod:

import { z } from 'zod';

const requestSchema = z.object({
  leadId: z.string().uuid(),
  transcript: z.string().min(1),
});

Integration with tRPC
If using tRPC for API communication, you can define the procedures as follows:
// src/server/routers/analyzeTranscript.ts
import { z } from 'zod';
import { createRouter } from '../createRouter';

export const analyzeTranscriptRouter = createRouter().mutation('analyze', {
  input: z.object({
    leadId: z.string().uuid(),
    transcript: z.string().min(1),
  }),
  async resolve({ input }) {
    // Call the analyzeTranscript function and return the result
  },
});


Adding Documentation to a CMS
To make this API documentation easily accessible in a Content Management System (CMS), consider the following:
Markdown Support: Since the documentation is formatted in Markdown, choose a CMS that supports Markdown content for easy formatting (e.g., Strapi, Contentful, Netlify CMS).
Structured Content: Use the CMS's capabilities to structure the documentation into sections and subsections for better navigation.
Versioning: Implement version control within the CMS to track changes to the API and documentation over time.
Search: Enable search functionality within the CMS so users can quickly find specific endpoints or parameters.
Code Snippets Highlighting: Ensure the CMS supports syntax highlighting for code blocks to improve readability.
API Playground: Integrate tools like Swagger UI or Redoc to provide an interactive API explorer if exposing OpenAPI/Swagger documentation.
Suggestions:
Use Swagger/OpenAPI Specification:
Define your API using the OpenAPI Specification 3.0.
Tools like Swagger UI can generate interactive documentation.
Host the Swagger UI within your CMS or link to it.
Documentation Generators:
Use tools like Redoc or Slate to generate static documentation sites from your API definitions.
These can be integrated into your CMS as embedded content or linked pages.
CMS Platforms:
Strapi: An open-source Node.js CMS that supports custom content types. You can create a content type for API documentation and organize it accordingly.
Contentful: A headless CMS that allows for rich content modeling and can be integrated with your frontend for dynamic content delivery.
Static Site Generators:
Use Docusaurus or VuePress to create a documentation site.
These can be deployed alongside your main application on Vercel.
Custom Admin Interface:
Since you're using Next.js, you can create a custom admin interface for documentation, storing content in Markdown files or fetching from a CMS.
---
Conclusion
This API documentation provides details on the available endpoints, their usage, and how to integrate them into your application. By adding this documentation to a CMS, you ensure that it is easily accessible and maintainable for all team members.
---
Note
Type Safety: All code examples are written in type-safe TypeScript, adhering to your code style preferences.
No Line Numbers: Code snippets do not include line numbers, as per your instruction.
CMS Integration: Consider automating the documentation generation process to keep the API docs in sync with the codebase.
Let me know if you need further details or assistance with any specific part.


